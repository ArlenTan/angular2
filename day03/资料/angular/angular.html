<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:angular</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h2 id="angular4-x-">Angular4.x 介绍</h2>
<ul>
<li>Angualr 是一款来自谷歌的开源的 web 前端框架，诞生于 2009 年，由 Misko Hevery 等人创建，后为 Google 所购。是一款优秀的前端JS框架，已经被用于 Google 的多款产品当中。</li>
<li>2015 之前 Angular 1.x 得到了广泛的应用，开发单页面应用无人能敌。</li>
<li>2015 年底 Angular2.0 发布了，彻底的颠覆了之前的版本，学习 Angular 2.0 相当于重新学习另一个框架。</li>
<li>在质疑声中，angularjs 的开发团队宣布 1.X 版本和 2.x 版本同时维护。</li>
<li>AngularJs1.x 的时候被人们称为下一代 web 应用。由于 Angular2.0 以后是基于 TypeScript，和以前 angularjs1.x 的开发方式完全不一样,让很多的新手朋友觉得入门门槛比较高。</li>
<li>几经沉淀和积累，angualr4.x 的发布了， angualr4.x 是完全基于 angular2.x 的。他具有更小的体积、更快的运行速度、更快的编译速度、以及 AngularUniversal 也就是在服务器端渲染 Angular。</li>
</ul>
<h2 id="typescript-">TypeScript 介绍</h2>
<ul>
<li>TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</li>
</ul>
<h4 id="angular4-x-">Angular4.x能干什么</h4>
<ul>
<li>App和微信上的单面应用程序；</li>
<li>借助ionic 、React-native开发跨平台的原生APP；</li>
<li>可以开发桌面应用，创建能在桌面环境下安装的应用，横跨Mac、window、linux平台。</li>
</ul>
<h4 id="angular-">Angular开发工具</h4>
<ul>
<li>Visual Studio Code(链接)[<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>]</li>
</ul>
<h6 id="vs-code-">VS code 插件</h6>
<ul>
<li>Angular Files ：在vsc中集成angular-cli工具，可界面华新建component、directove、module、routing、pipe等feature</li>
<li>Auto Import：（重要）自动引入模块</li>
<li>Auto Rename Tag ： html的开始和结束标签同时更新</li>
<li>beautify: 代码格式化工具</li>
<li>Document This: 目前vscode上最好的ts注释插件(用法ctrl+alt+d然后再Ctrl+alt+e或者d，e是全部加注释，d是对当前方法加注释)</li>
<li>Path Intellisense ： 路径提醒工具，非常方便</li>
<li>Settings Sync ： 通过github账号的token设置不同机子vsc设置上的同步</li>
<li>TSlint ：ts语法代码质量检测</li>
<li>npm :在vsc中运行npm指令</li>
<li>TypeScript Toolbox ：typescript必备插件</li>
</ul>
<h2 id="angular4-x-">Angular4.x 安装、创建项目、 目录结构介绍、创建组件</h2>
<h4 id="-nodejs">安装 nodejs</h4>
<ul>
<li>注意：请先在终端/控制台窗口(win+R输入cmd)中运行命令 node -v 和 npm -v， 来验证一下你正在运行 node 6.9.x 和 npm 3.x.x 以上的版本。 更老的版本可能会出现错误，更新的版本则没问题。</li>
</ul>
<h4 id="-angular-cli-">全局安装 Angular CLI 脚手架工具(只需安装一次）</h4>
<ol>
<li>使用 npm 命令安装
<code>npm install -g @angular/cli</code></li>
<li>使用 cnpm 命令安装<ul>
<li>安装 cnpm<blockquote>
<p>npm 可能安装失败建议先用 npm 安装一下 cnpm 用淘宝镜像安装[<a href="https://npm.taobao.org/">https://npm.taobao.org/</a>]
<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
</blockquote>
</li>
<li>使用cnpm安装Angular CLI 脚手架
<code>cnpm install -g @angular/cli</code></li>
</ul>
</li>
</ol>
<h4 id="-">创建项目</h4>
<ol>
<li><p>打开 cmd 找到你要创建项目的目录</p>
</li>
<li><p>创建项目</p>
</li>
<li>ng new 项目名称    //创建一个项目
<code>ng new my-App</code></li>
<li>进入刚才创建的项目里面启动服务
<code>cd my-App</code>
<code>npm install</code>
<code>ng serve --open</code></li>
</ol>
<h4 id="-">目录结构介绍</h4>
<h6 id="-">根目录下的目录结构</h6>
<ul>
<li>e2e : 端对端测试目录，主要用于自动化测试</li>
<li><p>或者 ：在e2e/下是端到端（end-to-end）测试。 它们不在src/下，是因为端到端测试实际上和应用是相互独立的，它只适用于测试你的应用而已。 这也就是为什么它会拥有自己的tsconfig.json。</p>
</li>
<li><p>node_modules : 第三方依赖包目录</p>
</li>
<li><p>或者:<code>Node.js</code>创建了这个文件夹，并且把<code>package.json</code>中列举的所有第三方模块都放在其中。</p>
</li>
<li><p>src : 项目源代码目录</p>
</li>
<li><p>.angular-cli.json ： Angular命令行工具配置文件，可以修改它引入第三方的包，如jquery，bootstrap</p>
</li>
<li><p>或者: Angular CLI的配置文件。 在这个文件中，我们可以设置一系列默认值，还可以配置项目编译时要包含的那些文件。 要了解更多，请参阅它的官方文档。</p>
</li>
<li><p>.editorconfig : 编辑器配置文件</p>
</li>
<li><p>或者: 给你的编辑器看的一个简单配置文件，它用来确保参与你项目的每个人都具有基本的编辑器配置。 大多数的编辑器都支持.editorconfig文件，详情参见 [<a href="http://editorconfig.org">http://editorconfig.org</a>] 。</p>
</li>
<li><p>.gittgnore : git配置文件</p>
</li>
<li><p>或者: 一个Git的配置文件，用来确保某些自动生成的文件不会被提交到源码控制系统中。</p>
</li>
<li><p>karma.conf.js : karma是单元测试的执行器，karma.conf.js是karma的配置文件</p>
</li>
<li><p>或者: 给<code>Karma</code>的单元测试配置，当运行ng test时会用到它。</p>
</li>
<li><p>package.json : npm工具配置文件，列出该应用使用的依赖包</p>
</li>
<li><p>npm配置文件，其中列出了项目使用到的第三方依赖包。 你还可以在这里添加自己的自定义脚本。</p>
</li>
<li><p>protractor.conf.js : 自动化测试配置文件</p>
</li>
<li><p>给Protractor使用的端到端测试配置文件，当运行ng e2e的时候会用到它。</p>
</li>
<li><p>REAADME.md : 说明文件</p>
</li>
<li><p>项目的基础文档，预先写入了CLI命令的信息。 别忘了用项目文档改进它，以便每个查看此仓库的人都能据此构建出你的应用。</p>
</li>
<li><p>tsconfig.json : 指定ts编译的一些参数信息</p>
</li>
<li><p>TypeScript编译器的配置，你的IDE会借助它来给你提供更好的帮助。</p>
</li>
<li><p>tslint.json : tslint的配置文件，定义TypeScript代码质量检测规则</p>
</li>
<li>给<code>TSLint</code>和<code>Codelyzer</code>用的配置信息，当运行ng lint时会用到。 Lint功能可以帮你保持代码风格的统一</li>
</ul>
<h6 id="src-">src目录下的目录结构</h6>
<ul>
<li><p>app : 包含应用的组件和模块，我们要写的代码都在这个目录</p>
<blockquote>
<p>{.html | .ts | .css}</p>
<ul>
<li>使用HTML模板、CSS样式和单元测试定义AppComponent组件。 它是根组件，随着应用的成长它会成为一棵组件树的根节点。</li>
</ul>
</blockquote>
</li>
<li><p>assets : 资源目录，主要存放静态资源，如图片</p>
</li>
<li><p>或者：这个文件夹下你可以放图片等任何东西，在构建应用时，它们全都会拷贝到发布包中。</p>
</li>
<li><p>environment : 环境配置。Angular是支持多环境开发的，我们可以在不同的环境下（开发环境，测试环境，生产环境）共用一套代码</p>
</li>
<li><p>或者: 这个文件夹中包括为各个目标环境准备的文件，它们导出了一些应用中要用到的配置变量。 这些文件会在构建应用时被替换。 比如你可能在产品环境中使用不同的API端点地址，或使用不同的统计Token参数。 甚至使用一些模- 拟服务。 所有这些，CLI都替你考虑到了。</p>
</li>
<li><p>favicon.ico : 网站标题栏图标</p>
</li>
<li><p>或者: 每个网站都希望自己在书签栏中能好看一点。 请把它换成你自己的图标。</p>
</li>
<li><p>index.html：应用的根页面，程序启动访问页面</p>
</li>
<li><p>或者：这是别人访问你的网站是看到的主页面的HTML文件。 大多数情况下你都不用编辑它。 在构建应用时，CLI会自动把所有js和css文件添加进去，所以你不必在这里手动添加任何 <code>&lt;script&gt;</code> 或<code>&lt;link&gt;</code>标签。</p>
</li>
<li><p>main.ts：应用的入口，Angular通过此文件启动应用</p>
</li>
<li>或者:这是应用的主要入口点。 使用JIT compiler编译器编译本应用，并启动应用的根模块AppModule，使其运行在浏览器中。</li>
<li><p>你还可以使用AOT compiler编译器，而不用修改任何代码 —— 只要给ng build 或 ng serve 传入  --aot 参数就可以了。</p>
</li>
<li><p>polyfills.ts：导入一些库使Angular能在老版本运行</p>
</li>
<li><p>或者:不同的浏览器对Web标准的支持程度也不同。 填充库（<code>polyfill</code>）能帮我们把这些不同点进行标准化。 你只要使用<code>core-js</code>和 <code>zone.js</code>通常就够了，不过你也可以查看浏览器支持指南以了解更多信息。</p>
</li>
<li><p>styles.css：全局的css样式</p>
</li>
<li><p>或者: 全局样式。 大多数情况下，会在组件中使用局部样式，以利于维护，不过那些会影响你整个应用的样式你还是需要集中存放在这里。</p>
</li>
<li><p>test.ts: 这是单元测试的主要入口点。 它有一些你不熟悉的自定义配置，不过你并不需要编辑这里的任何东西。</p>
</li>
<li><p>tsconfig.app.json：TypeScript编译器的配置,添加第三方依赖的时候会修改这个文件</p>
</li>
<li>或者：<code>TypeScript</code>编译器的配置文件。<code>tsconfig.app.json</code>是为Angular应用准备的，而<code>tsconfig.spec.json</code>是为单元测试准备的。</li>
</ul>
<h2 id="-">组件化解读</h2>
<h4 id="-">组件化概念</h4>
<ul>
<li>页面上的每个 独立的 可视/可交互区域视为一个组件;</li>
<li>每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护;</li>
<li>每个组件相对独立，页面只不过是组件的容器，组件自由组合形成功能完整的界面;</li>
<li>当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。<h4 id="-">组件化开发的好处</h4>
</li>
<li>标记鲜明，容易维护，组件化后，我们只需要对对应的组件进行维护，不会影响到其它文件。而且文件结构清楚，方便后台人员的使用。</li>
<li>块状化结构，减少css 的书写，并且方便扩展</li>
</ul>
<h2 id="hello-angular-4-0-app-module-ts-">Hello Angular 4.0 以及 app.module.ts、组件分析</h2>
<h4 id="app-module-ts">app.module.ts</h4>
<ul>
<li>定义AppModule，这个根模块会告诉Angular如何组装该应用。 目前，它只声明了AppComponent。 稍后它还会声明更多组件。</li>
<li>Angular 模块类描述应用的部件是如何组合在一起的。 每个应用都至少有一个 Angular 模块，也就是根模块；</li>
<li>用来引导并运行应用。 你可以为它取任何名字。常规名字是AppModule。 也就是 app.module.ts文件</li>
</ul>
<pre><code class="lang-typescript">/*引入组件*/
import { BrowserModule } from &#39;@angular/platform-browser&#39;; /*BrowserModule，浏览器解析的模块*/
import { NgModule } from &#39;@angular/core&#39;; /*angualrjs核心模块*/
import { FormsModule } from &#39;@angular/forms&#39;; /*表单数据绑定 表单验证需要的模块*/
import { HttpModule } from &#39;@angular/http&#39;; /*数据请求模块*/
import { AppComponent } from &#39;./app.component&#39;; /*根组件*/ /*@NgModule装饰器将AppModule标记为 Angular 模块类（也叫NgModule类）。
 @NgModule接受一个元数据对象，告诉 Angular 如何编译和启动应用。*/
  @NgModule({
      declarations: [ /*引入当前项目运行的的组件*/ AppComponent ],
      imports: [ /*引入当前模块运行依赖的其他模块*/ BrowserModule, FormsModule, HttpModule ],
       providers: [], /*定义的服务 回头放在这个里面*/ bootstrap: [AppComponent]
       /* 指定应用的主视图（称为根组件） 通过引导根AppModule来启动应用 ，这里一般写的是根组件*/
    })

    /*根模块不需要导出任何东西， 因为其它组件不需要导入根模块。 但是一定要写*/
 export class AppModule { }
</code></pre>
<h4 id="-">自定义组件</h4>
<h6 id="-compontents-header-">创建compontents下header组件：</h6>
<p><code>ng g component components/header</code></p>
<h6 id="-">组件内容详解：</h6>
<pre><code class="lang-typescript">import { Component, OnInit } from &#39;@angular/core&#39;; /*引入angular核心*/
@Component({
    selector: &#39;app-header&#39;, /*使用这个组件的名称*/
    templateUrl: &#39;./header.component.html&#39;, /*html模板*/
    styleUrls: [&#39;./header.component.css&#39;] /*css样式*/
})
 export class HeaderComponent implements OnInit { /*实现接口*/
    constructor() { /*构造函数*/ }
    ngOnInit() { /*初始化加载的生命周期函数*/ }
}
</code></pre>
<h6 id="-">使用组件</h6>
<p><code>&lt;app-header&gt;&lt;/app-header&gt;</code></p>
<h2 id="angular4-0-">Angular4.0绑定数据、绑定属性、数据循环、条件判断、事件、双向数据绑定</h2>
<h4 id="angualr4-0-">angualr4.0绑定数据</h4>
<h6 id="-">数据文本绑定 {{}}</h6>
<p><code>&lt;h1&gt;{{title}}&lt;/h1&gt;</code></p>
<h6 id="-html">绑定html</h6>
<p><code>this.h=&quot;&lt;h2&gt;这是一个h2用[innerHTML]来解析&lt;/h2&gt;&quot;</code>
<code>&lt;div [innerHTML]=&quot;h&quot;&gt;&lt;/div&gt;</code></p>
<h4 id="-ngfor">数据循环 *ngFor</h4>
<pre><code class="lang-typescript">&lt;ul&gt;
    &lt;li *ngFor=&quot;let item of list&quot;&gt; {{item}} &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h6 id="-key-ul-">循环的时候设置key <ul></h6>
<pre><code class="lang-typescript">&lt;ul&gt;
    &lt;li *ngFor=&quot;let item of list;let i = index;&quot;&gt; {{item}} --{{i}} &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h6 id="template-">template循环数据</h6>
<pre><code class="lang-typescript">&lt;ul&gt;
     &lt;li template=&quot;ngFor let item of list&quot;&gt; {{item}} &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h4 id="-ngif">条件判断 *ngIf</h4>
<p><code>&lt;p *ngIf=&quot;list.length &gt; 3&quot;&gt;这是ngIF判断是否显示&lt;/p&gt;</code>
<code>&lt;p template=&quot;ngIf list.length &gt; 3&quot;&gt;这是ngIF判断是否显示&lt;/p&gt;</code></p>
<h4 id="-click-getdata-">执行事件 (click)=”getData()”</h4>
<p><code>&lt;button class=&quot;button&quot; (click)=&quot;getData()&quot;&gt; 点击按钮触发事件 &lt;/button&gt;</code></p>
<p><code>&lt;button class=&quot;button&quot; (click)=&quot;setData()&quot;&gt; 点击按钮设置数据 &lt;/button&gt;</code></p>
<p><code>getData(){ /*自定义方法获取数据*/ //获取 alert(this.msg); }</code></p>
<p><code>setData(){ //设置值 this.msg=&#39;这是设置的值&#39;; }</code></p>
<h4 id="-">绑定属性</h4>
<ul>
<li>使用[]号把对应属性绑定起来
<code>绑定属性 &lt;div [id]=&quot;id&quot; [title]=&quot;msg&quot;&gt;调试工具看看我的属性&lt;/div&gt;</code></li>
</ul>
<h4 id="-">八、双向数据绑定</h4>
<p><code>&lt;input [(ngModel)]=&quot;inputValue&quot;&gt;</code></p>
<pre><code>&gt; 提示：注意引入：FormsModule(在对应的.ts文件中引入FoemModule)
</code></pre><p><code>import { FormsModule } from &#39;@angular/forms&#39;;</code></p>
<ul>
<li>app.modules.ts中也要引入FormsModule依赖<pre><code class="lang-typescript">@NgModule({
  declarations: [ AppComponent, HeaderComponent, FooterComponent, NewsComponent ],
   imports: [ BrowserModule, FormsModule ],
   providers: [],
   bootstrap: [AppComponent]
  })
export class AppModule { }
</code></pre>
使用：<pre><code class="lang-typescript">&lt;input type=&quot;text&quot; [(ngModel)]=&quot;inputValue&quot;/&gt;
{{inputValue}}
</code></pre>
</li>
</ul>
<h2 id="angular4-x-">Angular4.x创建使用服务</h2>
<h4 id="-">什么是服务</h4>
<ul>
<li>在angular4.0中，服务可以视为一段复用性强的逻辑代码，因此组件中的公共逻辑部分就可以抽取出来作为一个服务，然后再把服务注入到组件中使用，虽然过程有点复杂，但是这样可以减少冗余，大大提高代码质量。</li>
</ul>
<h4 id="-">创建服务命令</h4>
<p><code>ng g service my-new-service</code></p>
<ul>
<li>创建到指定目录下面
<code>ng g service services/storage</code></li>
</ul>
<h4 id="app-module-ts-">app.module.ts里面引入创建的服务</h4>
<ol>
<li><p>app.module.ts 里面引入创建的服务
<code>import { StorageService } from &#39;./services/storage.service&#39;;</code></p>
</li>
<li><p>NgModule 里面的providers 里面依赖注入服务</p>
<pre><code class="lang-typescript">@NgModule({
 declarations: [ AppComponent, HeaderComponent, FooterComponent, NewsComponent, TodolistComponent ],
 imports: [ BrowserModule, FormsModule ],
 providers: [StorageService],
 bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
</li>
</ol>
<h4 id="-">使用的页面引入服务，注册服务</h4>
<h6 id="-">页面引入服务</h6>
<pre><code class="lang-typescript">
import { StorageService } from &#39;../../services/storage.service&#39;;

constructor(private storage: StorageService) { }
</code></pre>
<h6 id="-">使用服务</h6>
<pre><code class="lang-typescript">addData(){ // alert(this.username);
            this.list.push(this.username);
            this.storage.set(&#39;todolist&#39;,this.list);
        }
removerData(key){
    console.log(key);
    this.list.splice(key,1);
    this.storage.set(&#39;todolist&#39;,this.list);
    }
</code></pre>
<h2 id="angular4-x-get-post-jsonp-">Angular4.x get post以及 jsonp请求数据</h2>
<h4 id="app-module-ts-http-jsonp-">app.module.ts注册HTTP JSONP服务</h4>
<h6 id="-httpmodule-jsonpmodul">引入HttpModule 、JsonpModul</h6>
<ul>
<li>普通的HTTP请求需要HttpModule模块</li>
<li>JSONP方式请求需要引入JsonpModul模块
<code>import { HttpModule, JsonpModule } from &#39;@angular/http&#39;;</code></li>
</ul>
<h6 id="httpmodule-jsonpmodule-">HttpModule 、JsonpModule依赖注入</h6>
<ul>
<li>在app.modules.ts 的imports中引入HttpModule 、JsonpModule两个模块；<pre><code class="lang-typescript">@NgModule({
  declarations: [ AppComponent, HomeComponent, NewsComponent, NewscontentComponent ],
  imports: [ BrowserModule, FormsModule, HttpModule, JsonpModule, AppRoutingModule ],
  providers: [StorageService,NewsService],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
</li>
</ul>
<h4 id="-http-jsonp-">通过 Http、Jsonp请求数据</h4>
<ul>
<li>在需要请求数据的地方引入 Http
<code>import {Http,Jsonp} from &quot;@angular/http&quot;;</code></li>
</ul>
<ul>
<li><p>构造函数内申明：
<code>constructor(private http:Http,private jsonp:Jsonp) { }</code></p>
</li>
<li><p>对应的方法内使用http请求数据</p>
</li>
<li><p>get请求</p>
<pre><code class="lang-typescript">this.http.get(&quot;http://www.xxx.com/appapi.php?a=100&amp;catid=20&amp;page=1&quot;)
      .subscribe(
           function(data){ console.log(data); },
           function(err){ console.log(&#39;失败&#39;); }
          );
</code></pre>
</li>
<li><p>jsonp请求</p>
<pre><code class="lang-typescript">this.jsonp.get(&quot;http://www.xxx.com/appapi.php?a=100&amp;catid=20&amp;page=1&amp;callback=JSONP_CALLBACK&quot;)
      .subscribe(
           function(data){ console.log(data); },
           function(err){ console.log(&#39;失败&#39;); }
      );
</code></pre>
</li>
<li><p>post请求，post请求过程稍微复杂点，因为要声明请求头</p>
</li>
<li><p>引入Headers、Http模块
<code>import {Http,Jsonp,Headers} from &quot;@angular/http&quot;;</code></p>
</li>
<li><p>实例化Headers
<code>private headers = new Headers({&#39;Content-Type&#39;: &#39;application/json&#39;});</code></p>
</li>
<li><p>post提交数据
```typescript</p>
</li>
</ul>
<p>this.http .post(&#39;<a href="http://xxx/api/test">http://xxx/api/test</a>&#39;, JSON.stringify({username: &#39;admin&#39;}), {headers:this.headers})
            .subscribe(
                function(res){ console.log(res.json()); }
            );</p>
<pre><code>
##  Angular4.x get post以及 jsonp请求数据,使用Rxjs
#### 什么是Rxjs
- RxJS是一种针对异步数据流编程工具，或者叫响应式扩展编程；可不管如何解释RxJS其目标就是异步编程，Angular引入RxJS为了就是让异步可控、更简单。

#### 引入Http模块Jsonp模块，以及rxjs
    &gt; 大部分RxJS操作符都不包括在Angular的Observable基本实现中，基本实现只包括Angular本身所需的功能。
    &gt; 如果想要更多的RxJS功能，我们必须导入其所定义的库来扩展Observable对象， 以下是这个模块所需导入的所有RxJS操作符：
1. 引入Http 、Jsonp、RxJs 模块
```typescript
import {Http,Jsonp} from &quot;@angular/http&quot;;
import {Observable} from &quot;rxjs&quot;;
import &quot;rxjs/Rx&quot;;
</code></pre><pre><code>&gt; 这种import &#39;rxjs/Rx&#39;语法，它缺少了花括号中的导入列表：{...}。
&gt; 这是因为我们并不需要操作符本身，这种情况下，我们所做的其实是导入这个库，加载并运行其中的脚本， 它会把操作符添加到Observable类中。
</code></pre><ol>
<li><p>构造函数内申明：
<code>constructor(private http:Http,private jsonp:Jsonp) { }</code></p>
</li>
<li><p>get请求</p>
<pre><code class="lang-typescript">this.http.get(&quot;http://www.xxx.com/appapi.php?a=100&amp;catid=20&amp;page=1&quot;)
      .map(
          res =&gt; res.json()
      ) .subscribe( function(data){ console.log(data); } );
</code></pre>
</li>
<li><p>Jsonp请求</p>
<pre><code class="lang-typescript">this.jsonp.get(&quot;http://www.xxx.com/appapi.php?a=100&amp;catid=20&amp;page=1&amp;callback=JSONP_CALLBACK&quot;)
 .map(res =&gt; res.json())
 .subscribe( function(data){ console.log(data);} );
</code></pre>
<blockquote>
<p>http.get 方法中返回一个Observable对象，我们之后调用RxJS的map操作符对返回的数据做处理。</p>
</blockquote>
<h2 id="-">父子组件传值</h2>
<p>在每个独立的组件间想互相通讯，就要使用特定的修饰符来进行组件中的通讯。</p>
<h4 id="-input-">父组件给子组件传值 -@Input（父传子）</h4>
<ol>
<li><p>在父组件调用子组件的时候传入数据
<code>&lt;app-header [msg]=&quot;msg&quot;&gt;&lt;/app-header&gt;</code></p>
</li>
<li><p>子组件引入Input模块
<code>import { Component, OnInit ,Input } from &#39;@angular/core&#39;;</code></p>
</li>
<li><p>子组件中用@Input修饰符来接收父组件传过来的数据</p>
<pre><code class="lang-typescript">export class HeaderComponent implements OnInit {
@Input() msg:string
constructor() { }
ngOnInit() { }
}
</code></pre>
</li>
</ol>
</li>
<li><p>子组件中使用父组件的数据
<code>&lt;h2&gt;这是头部组件,由父组件传递过来的--{{msg}}&lt;/h2&gt;</code></p>
</li>
</ol>
<h4 id="-">父子组件传值的方式 让子组件执行父组件的方法（父传子）</h4>
<ol>
<li><p>父组件定义方法
<code>run(){ alert(&#39;这是父组件的run方法&#39;); }</code></p>
</li>
<li><p>调用子组件传入当前方法
<code>&lt;app-header [msg]=&quot;msg&quot; [run]=&quot;run&quot;&gt;&lt;/app-header&gt;</code></p>
</li>
<li><p>子组件接收父组件传过来的方法
```typescript</p>
</li>
</ol>
<p>import { Component, OnInit ,Input } from &#39;@angular/core&#39;;// 引入对应依赖
@Input() run:any; //用修饰符声明接收传入的方法</p>
<p>//在文件中接受父组件传入的数据写法如下：
export class HeaderComponent implements OnInit {
     @Input() msg:string // 接受父组件传入的msg数据
      @Input() run:any;  // 接受父组件传入的run方法
      constructor() { }
}</p>
<pre><code>
4. 子组件使用父组件的方法
```typescript
export class HeaderComponent implements OnInit {
    @Input() msg:string;
    @Input() run:any;
    constructor() { }
    ngOnInit() { this.run(); /*子组件调用父组件的run方法*/ }
}
</code></pre><h4 id="-output-">子组件通过@Output向父组件传入方法（子传父）</h4>
<ol>
<li><p>子组件引入Output 和 EventEmitter
<code>import { Component, OnInit ,Input,Output,EventEmitter} from &#39;@angular/core&#39;;</code></p>
</li>
<li><p>子组件中实例化 EventEmitter
<code>@Output() private outer=new EventEmitter&lt;string&gt;(); // 用EventEmitter 和output装饰器配合使用 &lt;string&gt;指定类型变量</code></p>
</li>
<li><p>子组件通过 EventEmitter 对象outer实例广播数据</p>
<pre><code class="lang-typescript">sendParent(){
 this.outer.emit(&#39;msg from child&#39;)
 }
</code></pre>
</li>
<li><p>父组件调用子组件的时候，定义接收事件 , outer就是子组件的EventEmitter 对象outer
<code>&lt;app-header (outer)=&quot;runParent($event)&quot;&gt;&lt;/app-header&gt;</code></p>
</li>
<li><p>父组件接收到数据会调用自己的runParent方法，这个时候就能拿到子组件的数据</p>
<pre><code class="lang-typescript">//接收子组件传递过来的数据
runParent(msg:string){
 alert(msg);
}
</code></pre>
</li>
</ol>
<h4 id="-">父组件通过局部变量获取子组件的引用 ，主动获取子组件的数据和方法（一）</h4>
<ol>
<li><p>定义footer子组件</p>
<pre><code class="lang-typescript">export class FooterComponent implements OnInit {
 public msg:string;
 constructor() { }
 ngOnInit() { }
 footerRun(){ alert(&#39;这是footer子组件的Run方法&#39;); }
}
</code></pre>
</li>
<li><p>父组件调用子组件的时候给子组件起个名字
<code>&lt;app-footer #footer&gt;&lt;/app-footer&gt;</code></p>
</li>
<li><p>直接获取执行子组件的方法
<code>&lt;button (click)=&#39;footer.footerRun()&#39;&gt;获取子组件的数据&lt;/button&gt;</code></p>
</li>
</ol>
<h4 id="-viewchild-">父组件通过局部变量获取子组件的引用,通过ViewChild主动获取子组件的数据和方法</h4>
<ol>
<li><p>调用子组件给子组件定义一个名称
<code>&lt;app-footer #footerChild&gt;&lt;/app-footer&gt;</code></p>
</li>
<li><p>父组件引入ViewChild
<code>import { Component, OnInit ,ViewChild} from &#39;@angular/core&#39;;</code></p>
</li>
<li><p>ViewChild和刚才的子组件关联起来
<code>@ViewChild(&#39;footerChild&#39;) footer;</code></p>
</li>
<li><p>调用子组件</p>
<pre><code class="lang-typescript">run(){
 this.footer.footerRun();
}
</code></pre>
</li>
</ol>
<h2 id="-">常用内置管道</h2>
<ul>
<li>uppercase  大写转换</li>
<li>uppercase 小写转换</li>
<li>number 数字格式化</li>
<li>data 日期格式化</li>
<li>json 对象序列化</li>
</ul>
<p>—— 用法 {{xxx|管道名称：管道参数(可选)}}</p>
<h4 id="angular4-">Angular4 内建管道使用示例</h4>
<ol>
<li><p>大写转换</p>
<pre><code class="lang-html">&lt;div&gt;
&lt;p ngNonBindable&gt;{{ &#39;Angular&#39; | uppercase }}&lt;/p&gt;
&lt;p&gt;{{ &#39;Angular&#39; | uppercase }}&lt;/p&gt; &lt;!-- Output: ANGULAR 输出的结果把字母全部转为大写--&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>.小写转换</p>
<pre><code class="lang-html">&lt;div&gt;
&lt;p ngNonBindable&gt;{{ &#39;Angular&#39; | lowercase }}&lt;/p&gt;
&lt;p&gt;{{ &#39;Angular&#39; | lowercase }}&lt;/p&gt; &lt;!-- Output: angular --&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>数值格式化</p>
<pre><code class="lang-html">&lt;div&gt;
&lt;p ngNonBindable&gt;{{ 3.14159265 | number: &#39;1.4-4&#39; }}&lt;/p&gt;
&lt;p&gt;{{ 3.14159265 | number: &#39;1.4-4&#39; }}&lt;/p&gt; &lt;!-- Output: 3.1416 1.4-4中表示1位整数，至少4位小数，至多4位小数--&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>日期格式化</p>
<pre><code class="lang-html">&lt;div&gt;
&lt;p ngNonBindable&gt;{{ today | date: &#39;shortTime&#39; }}&lt;/p&gt;
&lt;p&gt;{{ today | date: &#39;shortTime&#39; }}&lt;/p&gt; &lt;!-- Output: 以当前时间为准，输出格式：10:40 AM --&gt;
&lt;/div&gt;
</code></pre>
</li>
<li>JavaScript 对象序列化<pre><code class="lang-html">&lt;div&gt;
&lt;p ngNonBindable&gt;{{ { name: &#39;semlinker&#39; } | json }}&lt;/p&gt;
&lt;p&gt;{{ { name: &#39;semlinker&#39; } | json }}&lt;/p&gt; &lt;!-- Output: { &quot;name&quot;: &quot;semlinker&quot; } --&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h4 id="-">管道链</h4>
<ul>
<li>可以将多个管道连接在一起，组成管道链对数据进行处理。<pre><code class="lang-html">&lt;div&gt;
&lt;p ngNonBindable&gt;{{ &#39;semlinker&#39; | slice:0:3 | uppercase }}&lt;/p&gt;
&lt;p&gt;{{ &#39;semlinker&#39; | slice:0:3 | uppercase }}&lt;/p&gt; &lt;!-- Output: SEM --&gt;
&lt;/div&gt;
</code></pre>
</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>